# -*- coding: utf-8 -*-
"""modulo_prediccion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MdrqUtQC5xzDETtKF1xniXM82EqMR1U1

# Modulo de predicción

Autores: Samuel Suarez, Pablo Bright y Juan Pablo Guzman

---
"""

import joblib as jb
from sklearn.preprocessing import StandardScaler, LabelEncoder
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from google.oauth2 import service_account
from scipy.spatial import distance
import pandas as pd
import numpy as np
import sys
import math
import warnings
import os

# Suppress deprecation warnings
warnings.filterwarnings("ignore")

#Instalación de api de google para la lectura y escritura en archivo typo sheets por medio de google cloud
#pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib

"""Se cargan los modelos al sistema mediante la libreria joblib"""

forest = jb.load('forest.pkl')
ann = jb.load('ann.pkl')
tree = jb.load('tree.pkl')

"""Se ejecuta el modulo de limpieza con los parametros establecidos"""

os.system("python3 modulo_limpieza.py https://media.githubusercontent.com/media/pbright23/Estribot/main/data/data_1001/Location.csv https://media.githubusercontent.com/media/pbright23/Estribot/main/data/data_1001/Orientation.csv '2023-10-01 18:55:00' '2023-10-01 19:15:00' '[5.61,7.6,6.3,8.3,9.0,9.0,2.3,7.3,4.9,6.6,5.6,6.6]' '[7,61,59,73,86,75,90,104,106,82,89,86]' archive_output.csv")

data = pd.read_csv('archive_output.csv', header = 'infer', sep = ',')
x = data.drop(['last_time','first_time'], axis=1)

"""Se predicen las etiquetas correspondientes usando los modelos cargados junto con el conjunto de datos ya filtrado y recortado por el modelo de limpieza"""

y_pred_forest = forest.predict(x)
y_pred_ann = np.argmax(ann.predict(x), axis=1)
y_pred_tree = tree.predict(x)

data['good'] = float(0)
data['bad'] = float(0)
data['normal'] = float(0)

def get_result_supervized(data, pred, model):
  """
  Se realiza la votación de los modelos

  # Parametros
  - data: pd.Dataframe
  se utiliza para asignar un valor a las columnas 'good', 'normal' o 'bad' dependiendo de su valor asignado como modelo
  - pred: list
  lista de valores indicando a que grupo pertenece
  - model: String
  Se especifica cual de los modelos se esta utilizando, para determinar su valor de votación
  """
  multiplier = 1
  if model == 'forest':
    multiplier = 0.89
  elif model == 'tree':
    multiplier = 0.95
  elif model == 'ann':
    multiplier = 0.79
  result_forest, result_forest['target'] = data, pred
  for i in range(result_forest.shape[0]):
    if result_forest['target'].iloc[i] == 0:
      result_forest['good'].iloc[i] += multiplier
    if result_forest['target'].iloc[i] == 1:
      result_forest['bad'].iloc[i] += multiplier
    if result_forest['target'].iloc[i] == 2:
      result_forest['normal'].iloc[i] += multiplier
  return result_forest

data = get_result_supervized(data, y_pred_forest, 'forest')
data = get_result_supervized(data, y_pred_ann, 'ann')
data = get_result_supervized(data, y_pred_tree, 'tree')

data.drop(['target'], axis = 1, inplace = True)

data['chose'] = None
data['chose_percentage'] = None

"""Se le cambian los valores numericos de las etiquetas por valores tipo texto, junto con un valor de porcentaje correspondiente a la votación realizada por los tres modelos"""

for index,column in data.iterrows():
  value = max([data['good'][index], data['bad'][index] , data['normal'][index]])

  if value == data['good'][index]:
    data['chose'][index], data['chose_percentage'][index] = 'BUENO' , data['good'][index]/(data['bad'][index]+data['normal'][index]+data['good'][index])

  elif value == data['normal'][index]:
    data['chose'][index], data['chose_percentage'][index] = 'NORMAL', data['normal'][index]/(data['bad'][index]+data['normal'][index]+data['good'][index])

  elif value == data['bad'][index]:
    data['chose'][index], data['chose_percentage'][index] = 'MALO', data['bad'][index]/(data['bad'][index]+data['normal'][index]+data['good'][index])

  elif (data['bad'][index] == data['normal'][index]):
    data['chose'][index], data['chose_percentage'][index] = 'MALO-NORMAL', data['normal'][index]/(data['bad'][index]+data['normal'][index]+data['good'][index])

  elif (data['normal'][index] == data['good'][index]):
    data['chose'][index], data['chose_percentage'][index] = 'NORMAL-BUENO', data['normal'][index]/(data['bad'][index]+data['normal'][index]+data['good'][index])

  elif data['normal'][index] == data['good'][index] and data['bad'][index] == data['normal'][index] :
    data['chose'][index], data['chose_percentage'][index] = 'INCONCLUYENTE', 0

"""Se convierte los datos de velocidad (m/s) a nudos (knots)"""

data['min_speed'],data['max_speed'], data['first_speed'],data['last_speed'], data['mean_speed'] = data['min_speed'] * 1.94384,data['max_speed'] * 1.94384, data['first_speed'] * 1.94384,data['last_speed'] * 1.94384, data['mean_speed'] * 1.94384

"""Se calcula el vmg resultante para la posterior visualización"""

data['vmg'] = data['mean_speed'] * abs(np.cos(data['amplitude_yaw'] - data['wind_angles']))

"""Se convierten los datos de amplitud (radianes) a grados"""

data['amplitude_roll'] = np.degrees(data['amplitude_roll'])
data['amplitude_yaw'] = np.degrees(data['amplitude_yaw'])

"""Se exportan los datos a la hoja de calculo externa"""

SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
KEY = 'estribot-e054d85e6d49.json'
SPREADSHEET_ID = '1pgjFLZCyzYrdfd-2TWI3dGf3EZHzxz7y0wFb-taLVDs'

creds = None
creds = service_account.Credentials.from_service_account_file(KEY, scopes=SCOPES)

service = build('sheets', 'v4', credentials=creds)
sheet = service.spreadsheets()

# Debe ser una matriz por eso el doble [[]]
values = data.values.tolist()
values.insert(0,data.columns.values.tolist())
# Llamamos a la api

service.spreadsheets().values().clear(spreadsheetId=SPREADSHEET_ID, range='Hoja 1', body={}).execute()


result = sheet.values().update(spreadsheetId=SPREADSHEET_ID,
							range='A1',
							valueInputOption='USER_ENTERED',
							body={'values':values}).execute()

def matrix_to_text(matrix):
  comma = ', '
  text_result = []
  for i in matrix:
    result = comma.join(str(item) for item in i)
    text_result.append(result)
  return text_result

"""Se cargan los datos de latitud y longitud"""

location = pd.read_csv('tracker.csv', sep = ',', header = 'infer')
location_text = location[['latitude','longitude']].values.tolist()
location_text = matrix_to_text(location_text)
location['location'] = location_text
tmp = location[['time','location']].values.tolist()
tmp.insert(0, location[['time','location']].columns.values.tolist())

"""Se exportan los datos de localizacion (latitud y longitud) a la hoja de calculo externa"""

service.spreadsheets().values().clear(spreadsheetId=SPREADSHEET_ID, range='Hoja 2', body={}).execute()

result = sheet.values().update(spreadsheetId=SPREADSHEET_ID,
							range='\'Hoja 2\'!A1',
							valueInputOption='USER_ENTERED',
							body={'values':[[]]}).execute()
result = sheet.values().update(spreadsheetId=SPREADSHEET_ID,
							range='\'Hoja 2\'!A1',
							valueInputOption='USER_ENTERED',
							body={'values':tmp}).execute()

